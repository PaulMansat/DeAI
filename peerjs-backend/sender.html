<html>
  <body>
<div>
<input type="text" placeholder="Username" id="username">
<button onclick="register()">Register</button>
</div>

<div>
<input type="text" placeholder="Receivers" id="receivers">
<button onclick="send()">Send</button>
</div>

<div>
  <button onclick="train()">Train</button>
</div>
  

<script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.0.0/dist/tf.min.js"></script>
<script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js"></script>
<script src="./peer.js"></script>
<script src="./helpers.js"></script>
<script src="./mnist_data.js"></script>

<script>
console.log('start')


const model = tf.sequential({
 layers: [
   tf.layers.dense({inputShape: [784], units: 32, activation: 'relu'}),
   tf.layers.dense({units: 10, activation: 'softmax'}),
 ]
});

const model_compile_data = {
  optimizer   : 'sgd',
  loss        : 'categoricalCrossentropy',
  metrics     : ['accuracy']
}

const model_train_data = {
  epochs  : 5
}

var peerjs = null
var receivers = []
var recv_buffer = {}
var epoch = 0

function onEpochBegin() {
  console.log("EPOCH: ", ++epoch)
}

/**
 * Sends weights to all peers, waits to receive weights from all peers
 * and then averages peers' weights into the model.
*/
async function onEpochEnd() {
  const serialized_weights = await serializeWeights(model)
  const epoch_weights = {epoch : epoch, weights : serialized_weights}

  for (var i in receivers) {
    console.log("Sending weights to: ", receivers[i])
    await send_data(epoch_weights, CMD_CODES.AVG_WEIGHTS, peerjs, receivers[i])
  }

  if (recv_buffer.avg_weights === undefined) {
    console.log("Waiting to receive weights...")
    await data_received(recv_buffer, "avg_weights")
  }
  if (recv_buffer.avg_weights[epoch] === undefined) {
    console.log("Waiting to receive weights for this epoch...")
    await data_received(recv_buffer.avg_weights, epoch.toString())
  }
  console.log("Waiting to receive all weights for this epoch...")
  await check_array_len(recv_buffer.avg_weights[epoch], receivers.length)
    .then(() => {
      console.log("Averaging weights")
      for(i in recv_buffer.avg_weights[epoch]) {
        averageWeightsIntoModel(recv_buffer.avg_weights[epoch][i], model)
      }
      // might want to delete weights after using them to avoiding hogging memory
      // delete recv_buffer.avg_weights[epoch]
    })
}


// register peer name on PeerJS server
function register() {
  const username = document.getElementById("username").value

  peer = new Peer(username, {host: 'localhost', port: 9000, path: '/myapp'})
  peerjs = new PeerJS(peer, handle_data, recv_buffer)

}

// send model to comma-separated peers
async function send() {
    receivers = document.getElementById("receivers").value.split(',')
    var name = makeid(10) // random string
    for (i in receivers) {
      await send_model(model, peerjs, receivers[i], name)
      await send_data(model_compile_data, CMD_CODES.COMPILE_MODEL, peerjs, receivers[i])
      await send_data(model_train_data, CMD_CODES.TRAIN_INFO, peerjs, receivers[i])  
    }
}

// train model
async function train() {
  const mnist = new MnistData()
  await mnist.load()
  const [x_train_2d, y_train_2d] = mnist.getTrainData()
  const x_train_1d_ord = tf.reshape(x_train_2d, [x_train_2d.shape[0], -1])
  const y_train_1d_ord = tf.reshape(y_train_2d, [y_train_2d.shape[0], -1])

  // shuffle to avoid having the same thing on all peers
  var indices = tf.linspace(0, x_train_1d_ord.shape[0]).cast('int32')
  tf.util.shuffle(indices)
  const x_train_1d = x_train_1d_ord.gather(indices)
  const y_train_1d = y_train_1d_ord.gather(indices)


  model.compile(model_compile_data)
  console.log("Training started")
  await model.fit(x_train_1d, y_train_1d, {
    epochs : model_train_data.epochs,
    batchSize: 50,
    callbacks : {onEpochBegin, onEpochEnd}
  }).then((info) => console.log("Training finished", info.history))
}


</script>
  </body>
</html>
